{"version":3,"sources":["/source/OpaqueElementFinder.js","/source/src/OpaqueElementFinder.js"],"names":["global","factory","exports","module","define","amd","OpaqueElementFinder","this","elementIsTransparentByOpacity","element","alphaTolerance","elementOpacity","getComputedStyle","opacity","elementAlpha","normalizeAlphaLevel","elementsBackgroundIsTransparent","elementBackgroundColor","backgroundColor","elementBackgroundAlpha","getRgbAlphaLevel","colorString","test","matches","match","buildCanvasRenderingContextForImage","image","imgBoundaries","imgAsCanvas","document","createElement","width","height","canvasRenderingContext","getContext","drawImage","value","lastAlphaLevelInUse","undefined","parseFloat","Math","floor","Error","opaqueElementFromPoint","x","y","opacityTolerance","hiddenElemsInfo","opaqueElement","elementFromPoint","elementIsTransparentAtPoint","push","visibility","style","getPropertyValue","priority","getPropertyPriority","setProperty","forEach","info","documentElement","nodeName","imageIsTransparentAtPoint","globalX","globalY","getBoundingClientRect","localX","left","localY","top","pixel","getImageData","data"],"mappings":"CAAC,SAAUA,EAAQC,GACC,gBAAZC,UAA0C,mBAAXC,QAAyBA,OAAOD,QAAUD,IAC9D,kBAAXG,SAAyBA,OAAOC,IAAMD,OAAOH,GACpDD,EAAOM,oBAAsBL,KAC5BM,KAAM,WAAc,YCGP,SAASD,KAyEvB,QAASE,GAA+BC,EAASC,GAChD,GAAIC,GAAiBC,iBAAkBH,GAAUI,QAC7CC,EAAeC,EAAqBJ,EACxC,OAAuBD,IAAhBI,EAGR,QAASE,GAAiCP,EAASC,GAClD,GAAIO,GAAyBL,iBAAkBH,GAAUS,gBACrDC,EAAyBC,EAAkBH,EAC/C,OAAiCP,IAA1BS,EAGR,QAASC,GAAkBC,GAE1B,GAAoB,gBAAhBA,EACH,MAAO,EAER,IAAI,YAAYC,KAAMD,GACrB,MAAO,IAGR,IAAIE,GAAUF,EAAYG,MAAO,8BACjC,OAAOD,GACJR,EAAqBQ,EAAS,IAC9B,IA0BJ,QAASE,GAAqCC,EAAOC,GACpD,GAAIC,GAAcC,SAASC,cAAe,SAC1CF,GAAYG,MAAQJ,EAAcI,MAClCH,EAAYI,OAASL,EAAcK,MAEnC,IAAIC,GAAyBL,EAAYM,WAAY,KAGrD,OAFAD,GAAuBE,UAAWT,EAAO,EAAG,EAAGC,EAAcI,MAAOJ,EAAcK,QAE3EC,EAIR,QAASlB,GAAqBqB,GAC7B,GAAIA,IAAUC,EACb,MAAOD,EAER,IAAcE,SAAVF,EACH,MAAO,GAER,cAAeA,IACd,IAAK,SACJA,EAAQG,WAAYH,GACpBA,EAAQI,KAAKC,MAAO,IAAML,EAE3B,KAAK,SACJ,KAAgB,KAATA,GAAgBA,GAAS,GAC/B,KAAM,IAAIM,OAAO,4GAMpB,MADAL,GAAsBD,EACfA,EA3IR7B,KAAKoC,uBAAyB,SAAUC,EAAGC,EAAGC,GAM7C,IALA,GAAIpC,GAAiBK,EAAqB+B,GACtCC,KACAC,EAAgB,OAGN,CACb,GAAIvC,GAAUoB,SAASoB,iBAAkBL,EAAGC,EAE5C,IAAgB,OAAZpC,EACH,KAED,KAAKF,KAAK2C,4BAA6BzC,EAASmC,EAAGC,EAAGnC,GAAmB,CACxEsC,EAAgBvC,CAChB,OAEDsC,EAAgBI,MACf1C,QAASA,EACT2C,YACChB,MAAO3B,EAAQ4C,MAAMC,iBAAkB,cACvCC,SAAU9C,EAAQ4C,MAAMG,oBAAqB,iBAG/C/C,EAAQ4C,MAAMI,YAAa,aAAc,SAAU,aAOpD,MAJAV,GAAgBW,QAAS,SAAUC,GAClCA,EAAKlD,QAAQ4C,MAAMI,YAAa,aAAcE,EAAKP,WAAWhB,MAAOuB,EAAKP,WAAWG,YAG/EP,GAWRzC,KAAK2C,4BAA8B,SAAUzC,EAASmC,EAAGC,EAAGnC,GAE3D,MADAA,GAAiBK,EAAqBL,GAClCD,IAAYoB,SAAS+B,iBACjB,EAEJpD,EAA+BC,EAASC,IACpC,EAEJM,EAAiCP,EAASC,GAEjB,QAArBD,EAAQoD,UACXtD,KAAKuD,0BAA2BrD,EAASmC,EAAGC,EAAGnC,IAE7C,GAuCRH,KAAKuD,0BAA4B,SAAUpC,EAAOqC,EAASC,EAAStD,GACnEA,EAAiBK,EAAqBL,EACtC,IAAIiB,GAAgBD,EAAMuC,wBACtBC,EAASH,EAAUpC,EAAcwC,KACjCC,EAASJ,EAAUrC,EAAc0C,IAEjCpC,EAA0BR,EAAqCC,EAAOC,GAGtE2C,EAAQrC,EAAuBsC,aAAcL,EAAQE,EAAQ,EAAG,GAAII,IAExE,OAAOF,GAAO,IAAO5D,EActB,IAAI2B,MD+BJ,MAAO/B","file":"OpaqueElementFinder.min.js","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\tglobal.OpaqueElementFinder = factory()\n}(this, function () { 'use strict';\n\n\t/**\n\t * Constructor for configurable object offering the opaqueElementFromPoint() function.\n\t *\n\t * @author Daniel A. R. Werner <daniel.a.r.werner@gmail.com>\n\t *\n\t * @constructor\n\t */\n\tfunction OpaqueElementFinder() {\n\n\t\t/**\n\t\t * Returns the element with the highest z-index and opaque pixel at the given global\n\t     * coordinates. Similar to document.elementFromPoint() but useful when working with partially\n\t     * transparent images or other elements with opacity set.\n\t     *\n\t     * TODO: Implement several edge cases we do not yet support.\n\t\t *\n\t\t * @param {number} x\n\t\t * @param {number} y\n\t\t * @param {string|number} [opacityTolerance=\"0.05\"] Opacity above this level is considered\n\t\t *        as opaque enough for an element to be selected. Opacity as string or rgba alpha level\n\t\t *        as number between 0 (fully transparent) and 255 (fully opaque).\n\t\t * @return {HTMLElement|null}\n\t\t */\n\t\tthis.opaqueElementFromPoint = function( x, y, opacityTolerance ) {\n\t\t\tvar alphaTolerance = normalizeAlphaLevel( opacityTolerance );\n\t\t\tvar hiddenElemsInfo = [];\n\t\t\tvar opaqueElement = null;\n\t\t\tvar stackedImages = 0;\n\n\t\t\twhile( true ) {\n\t\t\t\tlet element = document.elementFromPoint( x, y );\n\n\t\t\t\tif( element === null ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( !this.elementIsTransparentAtPoint( element, x, y, alphaTolerance ) ) {\n\t\t\t\t\topaqueElement = element;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\thiddenElemsInfo.push( {\n\t\t\t\t\telement: element,\n\t\t\t\t\tvisibility: {\n\t\t\t\t\t\tvalue: element.style.getPropertyValue( 'visibility' ),\n\t\t\t\t\t\tpriority: element.style.getPropertyPriority( 'visibility' )\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\telement.style.setProperty( 'visibility', 'hidden', 'important' );\n\t\t\t}\n\n\t\t\thiddenElemsInfo.forEach( function( info ) {\n\t\t\t\tinfo.element.style.setProperty( 'visibility', info.visibility.value, info.visibility.priority );\n\t\t\t} );\n\n\t\t\treturn opaqueElement;\n\t\t};\n\n\t\t/**\n\t\t * Returns whether an element is transparent at a given global coordinate.\n\t\t *\n\t\t * TODO: Utilize this function in a \"OpacityByPointGuru\" module as opacityByPoint() which\n\t\t *  returns an element's opacity. Consider complex cases such as opacity + image with alpha.\n\t\t *\n\t\t * TODO: cover more cases such as transparent background but opaque border.\n\t\t */\n\t\tthis.elementIsTransparentAtPoint = function( element, x, y, alphaTolerance ) {\n\t\t\talphaTolerance = normalizeAlphaLevel( alphaTolerance );\n\t\t\tif( element === document.documentElement ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif( elementIsTransparentByOpacity( element, alphaTolerance ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif( elementsBackgroundIsTransparent( element, alphaTolerance ) ) {\n\t\t\t\t// Even a full-alpha image is opaque if it got a non-transparent background-color.\n\t\t\t\treturn element.nodeName !== 'IMG'\n\t\t\t\t\t|| this.imageIsTransparentAtPoint( element, x, y, alphaTolerance );\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\tfunction elementIsTransparentByOpacity( element, alphaTolerance ) {\n\t\t\tvar elementOpacity = getComputedStyle( element ).opacity;\n\t\t\tvar elementAlpha = normalizeAlphaLevel( elementOpacity );\n\t\t\treturn elementAlpha <= alphaTolerance ;\n\t\t}\n\n\t\tfunction elementsBackgroundIsTransparent( element, alphaTolerance ) {\n\t\t\tvar elementBackgroundColor = getComputedStyle( element ).backgroundColor;\n\t\t\tvar elementBackgroundAlpha = getRgbAlphaLevel( elementBackgroundColor );\n\t\t\treturn elementBackgroundAlpha <= alphaTolerance;\n\t\t}\n\n\t\tfunction getRgbAlphaLevel( colorString ) {\n\t\t\t// Cover FF giving color names rather than rgb on occasion:\n\t\t\tif( colorString === 'transparent' ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif( /^[a-z]+$/i.test( colorString ) ) {\n\t\t\t\treturn 255;\n\t\t\t}\n\t\t\t// Handle rgb(a) strings:\n\t\t\tvar matches = colorString.match( /^rgba.*,\\s*(\\d\\.?\\d*)\\s*\\)$/ );\n\t\t\treturn matches\n\t\t\t\t? normalizeAlphaLevel( matches[ 1 ] )\n\t\t\t\t: 255; // no RGBA but RGB\n\t\t}\n\n\t\t/**\n\t\t * Returns whether the given image element has a non-alpha pixel at the given point.\n\t\t *\n\t\t * @param {HTMLImageElement} image\n\t\t * @param {number} globalX\n\t\t * @param {number} globalY\n\t\t * @param {string|number} [alphaTolerance=\"0.1\"]\n\t\t * @return {boolean}\n\t\t */\n\t\tthis.imageIsTransparentAtPoint = function( image, globalX, globalY, alphaTolerance ) {\n\t\t\talphaTolerance = normalizeAlphaLevel( alphaTolerance );\n\t\t\tvar imgBoundaries = image.getBoundingClientRect();\n\t\t\tvar localX = globalX - imgBoundaries.left;\n\t\t\tvar localY = globalY - imgBoundaries.top;\n\n\t\t\tvar canvasRenderingContext =  buildCanvasRenderingContextForImage( image, imgBoundaries );\n\n\t\t\t/** @var [r,g,b,a] */\n\t\t\tvar pixel = canvasRenderingContext.getImageData( localX, localY, 1, 1 ).data;\n\n\t\t\treturn pixel[ 3 ] <= alphaTolerance;\n\t\t};\n\n\t\tfunction buildCanvasRenderingContextForImage( image, imgBoundaries ) {\n\t\t\tvar imgAsCanvas = document.createElement( 'canvas' );\n\t\t\timgAsCanvas.width = imgBoundaries.width;\n\t\t\timgAsCanvas.height = imgBoundaries.height;\n\n\t\t\tvar canvasRenderingContext = imgAsCanvas.getContext( '2d' );\n\t\t\tcanvasRenderingContext.drawImage( image, 0, 0, imgBoundaries.width, imgBoundaries.height );\n\n\t\t\treturn canvasRenderingContext;\n\t\t}\n\n\t\tvar lastAlphaLevelInUse = {}; // Unique initial value.\n\t\tfunction normalizeAlphaLevel( value ) {\n\t\t\tif( value === lastAlphaLevelInUse ) { // Optimization as often called with same value.\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif( value === undefined ) {\n\t\t\t\treturn 12; // floor( opacity \"0.05\" * 255 )\n\t\t\t}\n\t\t\tswitch( typeof value ) {\n\t\t\t\tcase 'string':\n\t\t\t\t\tvalue = parseFloat( value );\n\t\t\t\t\tvalue = Math.floor( 255 * value );\n\t\t\t\t\t// @noinspection fallthrough\n\t\t\t\tcase 'number':\n\t\t\t\t\tif( !( value <= 255 && value >= 0 ) ) {\n\t\t\t\t\t\tthrow new Error( 'expected a number between 0 and 255 or a ' +\n\t\t\t\t\t\t\t'string representing an opacity between \"0\" and \"1\", e.g. \"0.25\"' );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlastAlphaLevelInUse = value;\n\t\t\treturn value;\n\t\t}\n\t};\n\n\treturn OpaqueElementFinder;\n\n}));\n","/**\n * Constructor for configurable object offering the opaqueElementFromPoint() function.\n *\n * @author Daniel A. R. Werner <daniel.a.r.werner@gmail.com>\n *\n * @constructor\n */\nexport default function OpaqueElementFinder() {\n\n\t/**\n\t * Returns the element with the highest z-index and opaque pixel at the given global\n     * coordinates. Similar to document.elementFromPoint() but useful when working with partially\n     * transparent images or other elements with opacity set.\n     *\n     * TODO: Implement several edge cases we do not yet support.\n\t *\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {string|number} [opacityTolerance=\"0.05\"] Opacity above this level is considered\n\t *        as opaque enough for an element to be selected. Opacity as string or rgba alpha level\n\t *        as number between 0 (fully transparent) and 255 (fully opaque).\n\t * @return {HTMLElement|null}\n\t */\n\tthis.opaqueElementFromPoint = function( x, y, opacityTolerance ) {\n\t\tvar alphaTolerance = normalizeAlphaLevel( opacityTolerance );\n\t\tvar hiddenElemsInfo = [];\n\t\tvar opaqueElement = null;\n\t\tvar stackedImages = 0;\n\n\t\twhile( true ) {\n\t\t\tlet element = document.elementFromPoint( x, y );\n\n\t\t\tif( element === null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( !this.elementIsTransparentAtPoint( element, x, y, alphaTolerance ) ) {\n\t\t\t\topaqueElement = element;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thiddenElemsInfo.push( {\n\t\t\t\telement: element,\n\t\t\t\tvisibility: {\n\t\t\t\t\tvalue: element.style.getPropertyValue( 'visibility' ),\n\t\t\t\t\tpriority: element.style.getPropertyPriority( 'visibility' )\n\t\t\t\t}\n\t\t\t} );\n\t\t\telement.style.setProperty( 'visibility', 'hidden', 'important' );\n\t\t}\n\n\t\thiddenElemsInfo.forEach( function( info ) {\n\t\t\tinfo.element.style.setProperty( 'visibility', info.visibility.value, info.visibility.priority );\n\t\t} );\n\n\t\treturn opaqueElement;\n\t};\n\n\t/**\n\t * Returns whether an element is transparent at a given global coordinate.\n\t *\n\t * TODO: Utilize this function in a \"OpacityByPointGuru\" module as opacityByPoint() which\n\t *  returns an element's opacity. Consider complex cases such as opacity + image with alpha.\n\t *\n\t * TODO: cover more cases such as transparent background but opaque border.\n\t */\n\tthis.elementIsTransparentAtPoint = function( element, x, y, alphaTolerance ) {\n\t\talphaTolerance = normalizeAlphaLevel( alphaTolerance );\n\t\tif( element === document.documentElement ) {\n\t\t\treturn false;\n\t\t}\n\t\tif( elementIsTransparentByOpacity( element, alphaTolerance ) ) {\n\t\t\treturn true;\n\t\t}\n\t\tif( elementsBackgroundIsTransparent( element, alphaTolerance ) ) {\n\t\t\t// Even a full-alpha image is opaque if it got a non-transparent background-color.\n\t\t\treturn element.nodeName !== 'IMG'\n\t\t\t\t|| this.imageIsTransparentAtPoint( element, x, y, alphaTolerance );\n\t\t}\n\t\treturn false;\n\t};\n\n\tfunction elementIsTransparentByOpacity( element, alphaTolerance ) {\n\t\tvar elementOpacity = getComputedStyle( element ).opacity;\n\t\tvar elementAlpha = normalizeAlphaLevel( elementOpacity );\n\t\treturn elementAlpha <= alphaTolerance ;\n\t}\n\n\tfunction elementsBackgroundIsTransparent( element, alphaTolerance ) {\n\t\tvar elementBackgroundColor = getComputedStyle( element ).backgroundColor;\n\t\tvar elementBackgroundAlpha = getRgbAlphaLevel( elementBackgroundColor );\n\t\treturn elementBackgroundAlpha <= alphaTolerance;\n\t}\n\n\tfunction getRgbAlphaLevel( colorString ) {\n\t\t// Cover FF giving color names rather than rgb on occasion:\n\t\tif( colorString === 'transparent' ) {\n\t\t\treturn 0;\n\t\t}\n\t\tif( /^[a-z]+$/i.test( colorString ) ) {\n\t\t\treturn 255;\n\t\t}\n\t\t// Handle rgb(a) strings:\n\t\tvar matches = colorString.match( /^rgba.*,\\s*(\\d\\.?\\d*)\\s*\\)$/ );\n\t\treturn matches\n\t\t\t? normalizeAlphaLevel( matches[ 1 ] )\n\t\t\t: 255; // no RGBA but RGB\n\t}\n\n\t/**\n\t * Returns whether the given image element has a non-alpha pixel at the given point.\n\t *\n\t * @param {HTMLImageElement} image\n\t * @param {number} globalX\n\t * @param {number} globalY\n\t * @param {string|number} [alphaTolerance=\"0.1\"]\n\t * @return {boolean}\n\t */\n\tthis.imageIsTransparentAtPoint = function( image, globalX, globalY, alphaTolerance ) {\n\t\talphaTolerance = normalizeAlphaLevel( alphaTolerance );\n\t\tvar imgBoundaries = image.getBoundingClientRect();\n\t\tvar localX = globalX - imgBoundaries.left;\n\t\tvar localY = globalY - imgBoundaries.top;\n\n\t\tvar canvasRenderingContext =  buildCanvasRenderingContextForImage( image, imgBoundaries );\n\n\t\t/** @var [r,g,b,a] */\n\t\tvar pixel = canvasRenderingContext.getImageData( localX, localY, 1, 1 ).data;\n\n\t\treturn pixel[ 3 ] <= alphaTolerance;\n\t};\n\n\tfunction buildCanvasRenderingContextForImage( image, imgBoundaries ) {\n\t\tvar imgAsCanvas = document.createElement( 'canvas' );\n\t\timgAsCanvas.width = imgBoundaries.width;\n\t\timgAsCanvas.height = imgBoundaries.height;\n\n\t\tvar canvasRenderingContext = imgAsCanvas.getContext( '2d' );\n\t\tcanvasRenderingContext.drawImage( image, 0, 0, imgBoundaries.width, imgBoundaries.height );\n\n\t\treturn canvasRenderingContext;\n\t}\n\n\tvar lastAlphaLevelInUse = {}; // Unique initial value.\n\tfunction normalizeAlphaLevel( value ) {\n\t\tif( value === lastAlphaLevelInUse ) { // Optimization as often called with same value.\n\t\t\treturn value;\n\t\t}\n\t\tif( value === undefined ) {\n\t\t\treturn 12; // floor( opacity \"0.05\" * 255 )\n\t\t}\n\t\tswitch( typeof value ) {\n\t\t\tcase 'string':\n\t\t\t\tvalue = parseFloat( value );\n\t\t\t\tvalue = Math.floor( 255 * value );\n\t\t\t\t// @noinspection fallthrough\n\t\t\tcase 'number':\n\t\t\t\tif( !( value <= 255 && value >= 0 ) ) {\n\t\t\t\t\tthrow new Error( 'expected a number between 0 and 255 or a ' +\n\t\t\t\t\t\t'string representing an opacity between \"0\" and \"1\", e.g. \"0.25\"' );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tlastAlphaLevelInUse = value;\n\t\treturn value;\n\t}\n};\n"],"sourceRoot":"/source/"}