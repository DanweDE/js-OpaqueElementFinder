{"version":3,"sources":["OpaqueElementFinder.js","src/OpaqueElementFinder.js"],"names":[],"mappings":"AAAA,AAAC,CAAA,UAAU,MAAM,EAAE,OAAO,EAAE;AAC3B,QAAO,OAAO,KAAK,QAAQ,IAAI,OAAO,MAAM,KAAK,WAAW,GAAG,MAAM,CAAC,OAAO,GAAG,OAAO,EAAE,GACzF,OAAO,MAAM,KAAK,UAAU,IAAI,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,OAAO,CAAC,GAC5D,MAAM,CAAC,mBAAmB,GAAG,OAAO,EAAE,CAAA;CACtC,CAAA,CAAC,IAAI,EAAE,YAAY;AAAE,aAAY,CAAC;;;;;;;;;ACGpB,UAAS,mBAAA,GAAsB;;;;;;;;;;;;;;;;AAgB7C,MAAA,CAAK,sBAAA,GAAyB,UAAU,CAAA,EAAG,CAAA,EAAG,gBAAA,EAAmB;AAChE,OAAI,cAAA,GAAiB,mBAAA,CAAqB,gBAAA,CAAA,CAAA;AAC1C,OAAI,eAAA,GAAkB,EAAA,CAAA;AACtB,OAAI,aAAA,GAAgB,IAAA,CAAA;AACpB,OAAI,aAAA,GAAgB,CAAA,CAAA;;AAEpB,UAAO,IAAA,EAAO;AACb,QAAI,OAAA,GAAU,QAAA,CAAS,gBAAA,CAAkB,CAAA,EAAG,CAAA,CAAA,CAAA;;AAE5C,QAAI,OAAA,KAAY,IAAA,EAAO;AACtB,WAAA;KACJ;AACG,QAAI,CAAC,IAAA,CAAK,2BAAA,CAA6B,OAAA,EAAS,CAAA,EAAG,CAAA,EAAG,cAAA,CAAA,EAAmB;AACxE,kBAAA,GAAgB,OAAA,CAAA;AAChB,WAAA;KACJ;AACG,mBAAA,CAAgB,IAAA,CAAM;AACrB,YAAA,EAAS,OAAA;AACT,eAAA,EAAY;AACX,WAAA,EAAO,OAAA,CAAQ,KAAA,CAAM,gBAAA,CAAkB,YAAA,CAAA;AACvC,cAAA,EAAU,OAAA,CAAQ,KAAA,CAAM,mBAAA,CAAqB,YAAA,CAAA;MAClD;KACA,CAAA,CAAA;AACG,WAAA,CAAQ,KAAA,CAAM,WAAA,CAAa,YAAA,EAAc,QAAA,EAAU,WAAA,CAAA,CAAA;IACtD;;AAEE,kBAAA,CAAgB,OAAA,CAAS,UAAU,IAAA,EAAO;AACzC,QAAA,CAAK,OAAA,CAAQ,KAAA,CAAM,WAAA,CAAa,YAAA,EAAc,IAAA,CAAK,UAAA,CAAW,KAAA,EAAO,IAAA,CAAK,UAAA,CAAW,QAAA,CAAA,CAAA;IACxF,CAAA,CAAA;;AAEE,UAAO,aAAA,CAAA;GACT,CAAA;;;;;;;;;;AAUC,MAAA,CAAK,2BAAA,GAA8B,UAAU,OAAA,EAAS,CAAA,EAAG,CAAA,EAAG,cAAA,EAAiB;AAC5E,iBAAA,GAAiB,mBAAA,CAAqB,cAAA,CAAA,CAAA;AACtC,OAAI,OAAA,KAAY,QAAA,CAAS,eAAA,EAAkB;AAC1C,WAAO,KAAA,CAAA;IACV;AACE,OAAI,6BAAA,CAA+B,OAAA,EAAS,cAAA,CAAA,EAAmB;AAC9D,WAAO,IAAA,CAAA;IACV;AACE,OAAI,+BAAA,CAAiC,OAAA,EAAS,cAAA,CAAA,EAAmB;;AAEhE,WAAO,OAAA,CAAQ,QAAA,KAAa,KAAA,IACxB,IAAA,CAAK,yBAAA,CAA2B,OAAA,EAAS,CAAA,EAAG,CAAA,EAAG,cAAA,CAAA,CAAA;IACtD;AACE,UAAO,KAAA,CAAA;GACT,CAAA;;AAEC,WAAS,6BAAA,CAA+B,OAAA,EAAS,cAAA,EAAiB;AACjE,OAAI,cAAA,GAAiB,gBAAA,CAAkB,OAAA,CAAA,CAAU,OAAA,CAAA;AACjD,OAAI,YAAA,GAAe,mBAAA,CAAqB,cAAA,CAAA,CAAA;AACxC,UAAO,YAAA,IAAgB,cAAA,CAAA;GACzB;;AAEC,WAAS,+BAAA,CAAiC,OAAA,EAAS,cAAA,EAAiB;AACnE,OAAI,sBAAA,GAAyB,gBAAA,CAAkB,OAAA,CAAA,CAAU,eAAA,CAAA;AACzD,OAAI,sBAAA,GAAyB,gBAAA,CAAkB,sBAAA,CAAA,CAAA;AAC/C,UAAO,sBAAA,IAA0B,cAAA,CAAA;GACnC;;AAEC,WAAS,gBAAA,CAAkB,WAAA,EAAc;;AAExC,OAAI,WAAA,KAAgB,aAAA,EAAgB;AACnC,WAAO,CAAA,CAAA;IACV;AACE,OAAI,WAAA,CAAY,IAAA,CAAM,WAAA,CAAA,EAAgB;AACrC,WAAO,GAAA,CAAA;IACV;;AAEE,OAAI,OAAA,GAAU,WAAA,CAAY,KAAA,CAAO,6BAAA,CAAA,CAAA;AACjC,UAAO,OAAA,GACJ,mBAAA,CAAqB,OAAA,CAAS,CAAA,CAAA,CAAA,GAC9B,GAAA,CAAA;GACL;;;;;;;;;;;AAWC,MAAA,CAAK,yBAAA,GAA4B,UAAU,KAAA,EAAO,OAAA,EAAS,OAAA,EAAS,cAAA,EAAiB;AACpF,iBAAA,GAAiB,mBAAA,CAAqB,cAAA,CAAA,CAAA;AACtC,OAAI,aAAA,GAAgB,KAAA,CAAM,qBAAA,EAAA,CAAA;AAC1B,OAAI,MAAA,GAAS,OAAA,GAAU,aAAA,CAAc,IAAA,CAAA;AACrC,OAAI,MAAA,GAAS,OAAA,GAAU,aAAA,CAAc,GAAA,CAAA;;AAErC,OAAI,sBAAA,GAA0B,mCAAA,CAAqC,KAAA,EAAO,aAAA,CAAA,CAAA;;;AAG1E,OAAI,KAAA,GAAQ,sBAAA,CAAuB,YAAA,CAAc,MAAA,EAAQ,MAAA,EAAQ,CAAA,EAAG,CAAA,CAAA,CAAI,IAAA,CAAA;;AAExE,UAAO,KAAA,CAAO,CAAA,CAAA,IAAO,cAAA,CAAA;GACvB,CAAA;;AAEC,WAAS,mCAAA,CAAqC,KAAA,EAAO,aAAA,EAAgB;AACpE,OAAI,WAAA,GAAc,QAAA,CAAS,aAAA,CAAe,QAAA,CAAA,CAAA;AAC1C,cAAA,CAAY,KAAA,GAAQ,aAAA,CAAc,KAAA,CAAA;AAClC,cAAA,CAAY,MAAA,GAAS,aAAA,CAAc,MAAA,CAAA;;AAEnC,OAAI,sBAAA,GAAyB,WAAA,CAAY,UAAA,CAAY,IAAA,CAAA,CAAA;AACrD,yBAAA,CAAuB,SAAA,CAAW,KAAA,EAAO,CAAA,EAAG,CAAA,EAAG,aAAA,CAAc,KAAA,EAAO,aAAA,CAAc,MAAA,CAAA,CAAA;;AAElF,UAAO,sBAAA,CAAA;GACT;;AAEC,MAAI,mBAAA,GAAsB,EAAA,CAAA;AAC1B,WAAS,mBAAA,CAAqB,KAAA,EAAQ;AACrC,OAAI,KAAA,KAAU,mBAAA,EAAsB;;AACnC,WAAO,KAAA,CAAA;IACV;AACE,OAAI,KAAA,KAAU,SAAA,EAAY;AACzB,WAAO,EAAA,CAAA;IACV;AACE,WAAQ,OAAO,KAAA;AACd,SAAK,QAAA;AACJ,UAAA,GAAQ,UAAA,CAAY,KAAA,CAAA,CAAA;AACpB,UAAA,GAAQ,IAAA,CAAK,KAAA,CAAO,GAAA,GAAM,KAAA,CAAA,CAAA;AAAA;AAE3B,SAAK,QAAA;AACJ,SAAI,EAAG,KAAA,IAAS,GAAA,IAAO,KAAA,IAAS,CAAA,CAAA,EAAM;AACrC,YAAM,IAAI,KAAA,CAAO,2CAAA,GAChB,iEAAA,CAAA,CAAA;MACN;AACI,WAAA;AAAA,IACJ;AACE,sBAAA,GAAsB,KAAA,CAAA;AACtB,UAAO,KAAA,CAAA;GACT;EACC,CAAA;;ADQA,QAAO,mBAAmB,CAAC;CAE3B,CAAC,CAAE","file":"OpaqueElementFinder.js","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\tglobal.OpaqueElementFinder = factory()\n}(this, function () { 'use strict';\n\n\t/**\n\t * Constructor for configurable object offering the opaqueElementFromPoint() function.\n\t *\n\t * @author Daniel A. R. Werner <daniel.a.r.werner@gmail.com>\n\t *\n\t * @constructor\n\t */\n\tfunction OpaqueElementFinder() {\n\n\t\t/**\n\t\t * Returns the element with the highest z-index and opaque pixel at the given global\n\t     * coordinates. Similar to document.elementFromPoint() but useful when working with partially\n\t     * transparent images or other elements with opacity set.\n\t     *\n\t     * TODO: Implement several edge cases we do not yet support.\n\t\t *\n\t\t * @param {number} x\n\t\t * @param {number} y\n\t\t * @param {string|number} [opacityTolerance=\"0.05\"] Opacity above this level is considered\n\t\t *        as opaque enough for an element to be selected. Opacity as string or rgba alpha level\n\t\t *        as number between 0 (fully transparent) and 255 (fully opaque).\n\t\t * @return {HTMLElement|null}\n\t\t */\n\t\tthis.opaqueElementFromPoint = function( x, y, opacityTolerance ) {\n\t\t\tvar alphaTolerance = normalizeAlphaLevel( opacityTolerance );\n\t\t\tvar hiddenElemsInfo = [];\n\t\t\tvar opaqueElement = null;\n\t\t\tvar stackedImages = 0;\n\n\t\t\twhile( true ) {\n\t\t\t\tlet element = document.elementFromPoint( x, y );\n\n\t\t\t\tif( element === null ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( !this.elementIsTransparentAtPoint( element, x, y, alphaTolerance ) ) {\n\t\t\t\t\topaqueElement = element;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\thiddenElemsInfo.push( {\n\t\t\t\t\telement: element,\n\t\t\t\t\tvisibility: {\n\t\t\t\t\t\tvalue: element.style.getPropertyValue( 'visibility' ),\n\t\t\t\t\t\tpriority: element.style.getPropertyPriority( 'visibility' )\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\telement.style.setProperty( 'visibility', 'hidden', 'important' );\n\t\t\t}\n\n\t\t\thiddenElemsInfo.forEach( function( info ) {\n\t\t\t\tinfo.element.style.setProperty( 'visibility', info.visibility.value, info.visibility.priority );\n\t\t\t} );\n\n\t\t\treturn opaqueElement;\n\t\t};\n\n\t\t/**\n\t\t * Returns whether an element is transparent at a given global coordinate.\n\t\t *\n\t\t * TODO: Utilize this function in a \"OpacityByPointGuru\" module as opacityByPoint() which\n\t\t *  returns an element's opacity. Consider complex cases such as opacity + image with alpha.\n\t\t *\n\t\t * TODO: cover more cases such as transparent background but opaque border.\n\t\t */\n\t\tthis.elementIsTransparentAtPoint = function( element, x, y, alphaTolerance ) {\n\t\t\talphaTolerance = normalizeAlphaLevel( alphaTolerance );\n\t\t\tif( element === document.documentElement ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif( elementIsTransparentByOpacity( element, alphaTolerance ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif( elementsBackgroundIsTransparent( element, alphaTolerance ) ) {\n\t\t\t\t// Even a full-alpha image is opaque if it got a non-transparent background-color.\n\t\t\t\treturn element.nodeName !== 'IMG'\n\t\t\t\t\t|| this.imageIsTransparentAtPoint( element, x, y, alphaTolerance );\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\tfunction elementIsTransparentByOpacity( element, alphaTolerance ) {\n\t\t\tvar elementOpacity = getComputedStyle( element ).opacity;\n\t\t\tvar elementAlpha = normalizeAlphaLevel( elementOpacity );\n\t\t\treturn elementAlpha <= alphaTolerance ;\n\t\t}\n\n\t\tfunction elementsBackgroundIsTransparent( element, alphaTolerance ) {\n\t\t\tvar elementBackgroundColor = getComputedStyle( element ).backgroundColor;\n\t\t\tvar elementBackgroundAlpha = getRgbAlphaLevel( elementBackgroundColor );\n\t\t\treturn elementBackgroundAlpha <= alphaTolerance;\n\t\t}\n\n\t\tfunction getRgbAlphaLevel( colorString ) {\n\t\t\t// Cover FF giving color names rather than rgb on occasion:\n\t\t\tif( colorString === 'transparent' ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif( /^[a-z]+$/i.test( colorString ) ) {\n\t\t\t\treturn 255;\n\t\t\t}\n\t\t\t// Handle rgb(a) strings:\n\t\t\tvar matches = colorString.match( /^rgba.*,\\s*(\\d\\.?\\d*)\\s*\\)$/ );\n\t\t\treturn matches\n\t\t\t\t? normalizeAlphaLevel( matches[ 1 ] )\n\t\t\t\t: 255; // no RGBA but RGB\n\t\t}\n\n\t\t/**\n\t\t * Returns whether the given image element has a non-alpha pixel at the given point.\n\t\t *\n\t\t * @param {HTMLImageElement} image\n\t\t * @param {number} globalX\n\t\t * @param {number} globalY\n\t\t * @param {string|number} [alphaTolerance=\"0.1\"]\n\t\t * @return {boolean}\n\t\t */\n\t\tthis.imageIsTransparentAtPoint = function( image, globalX, globalY, alphaTolerance ) {\n\t\t\talphaTolerance = normalizeAlphaLevel( alphaTolerance );\n\t\t\tvar imgBoundaries = image.getBoundingClientRect();\n\t\t\tvar localX = globalX - imgBoundaries.left;\n\t\t\tvar localY = globalY - imgBoundaries.top;\n\n\t\t\tvar canvasRenderingContext =  buildCanvasRenderingContextForImage( image, imgBoundaries );\n\n\t\t\t/** @var [r,g,b,a] */\n\t\t\tvar pixel = canvasRenderingContext.getImageData( localX, localY, 1, 1 ).data;\n\n\t\t\treturn pixel[ 3 ] <= alphaTolerance;\n\t\t};\n\n\t\tfunction buildCanvasRenderingContextForImage( image, imgBoundaries ) {\n\t\t\tvar imgAsCanvas = document.createElement( 'canvas' );\n\t\t\timgAsCanvas.width = imgBoundaries.width;\n\t\t\timgAsCanvas.height = imgBoundaries.height;\n\n\t\t\tvar canvasRenderingContext = imgAsCanvas.getContext( '2d' );\n\t\t\tcanvasRenderingContext.drawImage( image, 0, 0, imgBoundaries.width, imgBoundaries.height );\n\n\t\t\treturn canvasRenderingContext;\n\t\t}\n\n\t\tvar lastAlphaLevelInUse = {}; // Unique initial value.\n\t\tfunction normalizeAlphaLevel( value ) {\n\t\t\tif( value === lastAlphaLevelInUse ) { // Optimization as often called with same value.\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif( value === undefined ) {\n\t\t\t\treturn 12; // floor( opacity \"0.05\" * 255 )\n\t\t\t}\n\t\t\tswitch( typeof value ) {\n\t\t\t\tcase 'string':\n\t\t\t\t\tvalue = parseFloat( value );\n\t\t\t\t\tvalue = Math.floor( 255 * value );\n\t\t\t\t\t// @noinspection fallthrough\n\t\t\t\tcase 'number':\n\t\t\t\t\tif( !( value <= 255 && value >= 0 ) ) {\n\t\t\t\t\t\tthrow new Error( 'expected a number between 0 and 255 or a ' +\n\t\t\t\t\t\t\t'string representing an opacity between \"0\" and \"1\", e.g. \"0.25\"' );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlastAlphaLevelInUse = value;\n\t\t\treturn value;\n\t\t}\n\t};\n\n\treturn OpaqueElementFinder;\n\n}));\n","/**\n * Constructor for configurable object offering the opaqueElementFromPoint() function.\n *\n * @author Daniel A. R. Werner <daniel.a.r.werner@gmail.com>\n *\n * @constructor\n */\nexport default function OpaqueElementFinder() {\n\n\t/**\n\t * Returns the element with the highest z-index and opaque pixel at the given global\n     * coordinates. Similar to document.elementFromPoint() but useful when working with partially\n     * transparent images or other elements with opacity set.\n     *\n     * TODO: Implement several edge cases we do not yet support.\n\t *\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {string|number} [opacityTolerance=\"0.05\"] Opacity above this level is considered\n\t *        as opaque enough for an element to be selected. Opacity as string or rgba alpha level\n\t *        as number between 0 (fully transparent) and 255 (fully opaque).\n\t * @return {HTMLElement|null}\n\t */\n\tthis.opaqueElementFromPoint = function( x, y, opacityTolerance ) {\n\t\tvar alphaTolerance = normalizeAlphaLevel( opacityTolerance );\n\t\tvar hiddenElemsInfo = [];\n\t\tvar opaqueElement = null;\n\t\tvar stackedImages = 0;\n\n\t\twhile( true ) {\n\t\t\tlet element = document.elementFromPoint( x, y );\n\n\t\t\tif( element === null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( !this.elementIsTransparentAtPoint( element, x, y, alphaTolerance ) ) {\n\t\t\t\topaqueElement = element;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thiddenElemsInfo.push( {\n\t\t\t\telement: element,\n\t\t\t\tvisibility: {\n\t\t\t\t\tvalue: element.style.getPropertyValue( 'visibility' ),\n\t\t\t\t\tpriority: element.style.getPropertyPriority( 'visibility' )\n\t\t\t\t}\n\t\t\t} );\n\t\t\telement.style.setProperty( 'visibility', 'hidden', 'important' );\n\t\t}\n\n\t\thiddenElemsInfo.forEach( function( info ) {\n\t\t\tinfo.element.style.setProperty( 'visibility', info.visibility.value, info.visibility.priority );\n\t\t} );\n\n\t\treturn opaqueElement;\n\t};\n\n\t/**\n\t * Returns whether an element is transparent at a given global coordinate.\n\t *\n\t * TODO: Utilize this function in a \"OpacityByPointGuru\" module as opacityByPoint() which\n\t *  returns an element's opacity. Consider complex cases such as opacity + image with alpha.\n\t *\n\t * TODO: cover more cases such as transparent background but opaque border.\n\t */\n\tthis.elementIsTransparentAtPoint = function( element, x, y, alphaTolerance ) {\n\t\talphaTolerance = normalizeAlphaLevel( alphaTolerance );\n\t\tif( element === document.documentElement ) {\n\t\t\treturn false;\n\t\t}\n\t\tif( elementIsTransparentByOpacity( element, alphaTolerance ) ) {\n\t\t\treturn true;\n\t\t}\n\t\tif( elementsBackgroundIsTransparent( element, alphaTolerance ) ) {\n\t\t\t// Even a full-alpha image is opaque if it got a non-transparent background-color.\n\t\t\treturn element.nodeName !== 'IMG'\n\t\t\t\t|| this.imageIsTransparentAtPoint( element, x, y, alphaTolerance );\n\t\t}\n\t\treturn false;\n\t};\n\n\tfunction elementIsTransparentByOpacity( element, alphaTolerance ) {\n\t\tvar elementOpacity = getComputedStyle( element ).opacity;\n\t\tvar elementAlpha = normalizeAlphaLevel( elementOpacity );\n\t\treturn elementAlpha <= alphaTolerance ;\n\t}\n\n\tfunction elementsBackgroundIsTransparent( element, alphaTolerance ) {\n\t\tvar elementBackgroundColor = getComputedStyle( element ).backgroundColor;\n\t\tvar elementBackgroundAlpha = getRgbAlphaLevel( elementBackgroundColor );\n\t\treturn elementBackgroundAlpha <= alphaTolerance;\n\t}\n\n\tfunction getRgbAlphaLevel( colorString ) {\n\t\t// Cover FF giving color names rather than rgb on occasion:\n\t\tif( colorString === 'transparent' ) {\n\t\t\treturn 0;\n\t\t}\n\t\tif( /^[a-z]+$/i.test( colorString ) ) {\n\t\t\treturn 255;\n\t\t}\n\t\t// Handle rgb(a) strings:\n\t\tvar matches = colorString.match( /^rgba.*,\\s*(\\d\\.?\\d*)\\s*\\)$/ );\n\t\treturn matches\n\t\t\t? normalizeAlphaLevel( matches[ 1 ] )\n\t\t\t: 255; // no RGBA but RGB\n\t}\n\n\t/**\n\t * Returns whether the given image element has a non-alpha pixel at the given point.\n\t *\n\t * @param {HTMLImageElement} image\n\t * @param {number} globalX\n\t * @param {number} globalY\n\t * @param {string|number} [alphaTolerance=\"0.1\"]\n\t * @return {boolean}\n\t */\n\tthis.imageIsTransparentAtPoint = function( image, globalX, globalY, alphaTolerance ) {\n\t\talphaTolerance = normalizeAlphaLevel( alphaTolerance );\n\t\tvar imgBoundaries = image.getBoundingClientRect();\n\t\tvar localX = globalX - imgBoundaries.left;\n\t\tvar localY = globalY - imgBoundaries.top;\n\n\t\tvar canvasRenderingContext =  buildCanvasRenderingContextForImage( image, imgBoundaries );\n\n\t\t/** @var [r,g,b,a] */\n\t\tvar pixel = canvasRenderingContext.getImageData( localX, localY, 1, 1 ).data;\n\n\t\treturn pixel[ 3 ] <= alphaTolerance;\n\t};\n\n\tfunction buildCanvasRenderingContextForImage( image, imgBoundaries ) {\n\t\tvar imgAsCanvas = document.createElement( 'canvas' );\n\t\timgAsCanvas.width = imgBoundaries.width;\n\t\timgAsCanvas.height = imgBoundaries.height;\n\n\t\tvar canvasRenderingContext = imgAsCanvas.getContext( '2d' );\n\t\tcanvasRenderingContext.drawImage( image, 0, 0, imgBoundaries.width, imgBoundaries.height );\n\n\t\treturn canvasRenderingContext;\n\t}\n\n\tvar lastAlphaLevelInUse = {}; // Unique initial value.\n\tfunction normalizeAlphaLevel( value ) {\n\t\tif( value === lastAlphaLevelInUse ) { // Optimization as often called with same value.\n\t\t\treturn value;\n\t\t}\n\t\tif( value === undefined ) {\n\t\t\treturn 12; // floor( opacity \"0.05\" * 255 )\n\t\t}\n\t\tswitch( typeof value ) {\n\t\t\tcase 'string':\n\t\t\t\tvalue = parseFloat( value );\n\t\t\t\tvalue = Math.floor( 255 * value );\n\t\t\t\t// @noinspection fallthrough\n\t\t\tcase 'number':\n\t\t\t\tif( !( value <= 255 && value >= 0 ) ) {\n\t\t\t\t\tthrow new Error( 'expected a number between 0 and 255 or a ' +\n\t\t\t\t\t\t'string representing an opacity between \"0\" and \"1\", e.g. \"0.25\"' );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tlastAlphaLevelInUse = value;\n\t\treturn value;\n\t}\n};\n"],"sourceRoot":"/source/"}